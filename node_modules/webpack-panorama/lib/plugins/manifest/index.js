"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PanoramaManifestPlugin = exports.manifestTemplatePath = exports.manifestSchema = void 0;
const tslib_1 = require("tslib");
const html_webpack_plugin_1 = tslib_1.__importDefault(require("html-webpack-plugin"));
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const loader_utils_1 = require("loader-utils");
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const webpack_1 = tslib_1.__importDefault(require("webpack"));
const ModuleDependency_1 = tslib_1.__importDefault(require("webpack/lib/dependencies/ModuleDependency"));
const identifier_1 = require("webpack/lib/util/identifier");
const manifest_1 = require("./manifest");
var manifest_2 = require("./manifest");
Object.defineProperty(exports, "manifestSchema", { enumerable: true, get: function () { return manifest_2.manifestSchema; } });
exports.manifestTemplatePath = path_1.default.resolve(__dirname, '../../../manifest-template.ejs');
class PanoramaEntryDependency extends ModuleDependency_1.default {
    // @ts-expect-error 'type' is defined as a property in class 'ModuleDependency', but is overridden here in 'PanoramaEntryDependency' as an accessor.
    get type() {
        return 'panorama entry';
    }
}
const addEntry = util_1.promisify(webpack_1.default.Compilation.prototype.addEntry);
class PanoramaManifestPlugin {
    constructor({ entries, entryFilename, ...options }) {
        this.entries = entries;
        this.entryFilename = entryFilename !== null && entryFilename !== void 0 ? entryFilename : '[path][name].[ext]';
        this.htmlWebpackPlugin = new html_webpack_plugin_1.default({
            filename: 'custom_ui_manifest.xml',
            inject: false,
            template: exports.manifestTemplatePath,
            xhtml: true,
            ...options,
        });
    }
    apply(compiler) {
        compiler.options.entry = {};
        this.htmlWebpackPlugin.apply(compiler);
        compiler.hooks.compilation.tap(this.constructor.name, (compilation, { normalModuleFactory }) => {
            compilation.dependencyFactories.set(PanoramaEntryDependency, normalModuleFactory);
        });
        compiler.hooks.make.tapPromise(this.constructor.name, async (compilation) => {
            var _a;
            let manifestName;
            let manifestContext;
            let entries;
            if (typeof this.entries === 'string') {
                manifestName = identifier_1.makePathsRelative(compiler.context, this.entries);
                manifestContext = path_1.default.dirname(this.entries);
                compilation.fileDependencies.add(this.entries);
                const { inputFileSystem } = compiler;
                const readFile = util_1.promisify(inputFileSystem.readFile.bind(inputFileSystem));
                const rawManifest = (await readFile(this.entries)).toString('utf8');
                try {
                    if (/\.ya?ml$/.test(this.entries)) {
                        entries = (_a = js_yaml_1.default.safeLoad(rawManifest)) !== null && _a !== void 0 ? _a : [];
                    }
                    else if (this.entries.endsWith('.json')) {
                        entries = JSON.parse(rawManifest);
                    }
                    else {
                        throw new Error(`Unknown file extension '${path_1.default.extname(this.entries)}'`);
                    }
                }
                catch (error) {
                    compilation.errors.push(new manifest_1.PanoramaManifestError(error.message, manifestName));
                    return;
                }
            }
            else {
                manifestContext = compiler.context;
                entries = this.entries;
            }
            try {
                manifest_1.validateManifest(entries, manifestName);
            }
            catch (error) {
                compilation.errors.push(error);
                return;
            }
            const entryModuleTypes = new Map();
            await Promise.all(entries.map(async (entry) => {
                var _a, _b;
                const name = (_a = entry.filename) !== null && _a !== void 0 ? _a : entry.import;
                const filename = (_b = entry.filename) !== null && _b !== void 0 ? _b : (() => {
                    const extension = module.userRequest.endsWith('.xml') ? 'xml' : 'js';
                    return loader_utils_1.interpolateName({ resourcePath: module.userRequest }, this.entryFilename.replace('[ext]', extension), { context: compiler.context });
                });
                const dep = new PanoramaEntryDependency(entry.import);
                dep.loc = { name };
                await addEntry.call(compilation, manifestContext, dep, { name, filename });
                const module = compilation.moduleGraph.getModule(dep);
                if (entry.type != null) {
                    if (module.userRequest.endsWith('.xml')) {
                        entryModuleTypes.set(module, entry.type);
                    }
                    else {
                        compilation.errors.push(new manifest_1.PanoramaManifestError(`JavaScript '${entry.import}' entry point should not have 'type'.`, manifestName));
                    }
                }
            }));
            const htmlHooks = html_webpack_plugin_1.default.getHooks(compilation);
            htmlHooks.beforeAssetTagGeneration.tap(this.constructor.name, (args) => {
                const xmlAssets = [];
                for (const [module, type] of entryModuleTypes) {
                    for (const chunk of compilation.chunkGraph.getModuleChunksIterable(module)) {
                        for (const file of chunk.files) {
                            if (file.endsWith('.xml')) {
                                xmlAssets.push({ file: args.assets.publicPath + file, type });
                            }
                        }
                    }
                }
                args.assets.xml = xmlAssets;
                return args;
            });
        });
    }
}
exports.PanoramaManifestPlugin = PanoramaManifestPlugin;
//# sourceMappingURL=index.js.map