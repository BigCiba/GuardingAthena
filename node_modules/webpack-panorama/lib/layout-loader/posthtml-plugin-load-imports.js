"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadImports = void 0;
const tslib_1 = require("tslib");
const posthtml_1 = tslib_1.__importDefault(require("posthtml"));
const util_1 = require("util");
const vm_1 = tslib_1.__importDefault(require("vm"));
const { parser, render } = posthtml_1.default();
function evaluateModule(publicPath, filename, source) {
    if (source === '')
        throw new Error("The child compilation didn't provide a result");
    const script = new vm_1.default.Script(source, { filename, displayErrors: true });
    const vmContext = {
        __webpack_public_path__: publicPath,
        exports: {},
        module: { exports: {} },
    };
    const sandbox = vm_1.default.createContext(vmContext);
    sandbox.module.exports = sandbox.exports;
    script.runInContext(sandbox);
    const exported = sandbox.module.exports;
    if (typeof exported !== 'string') {
        throw new TypeError(`${filename} expected to export constant string, but got ${typeof exported}`);
    }
    return exported;
}
const isImportMessage = (message) => message.type === 'import';
exports.loadImports = (context) => async (tree) => {
    var _a;
    const publicPath = context._compilation.getPath((_a = context._compilation.outputOptions.publicPath) !== null && _a !== void 0 ? _a : '');
    let html = render(tree);
    const loadedModules = await Promise.all(tree.messages.filter(isImportMessage).map(async (message) => {
        const source = await util_1.promisify(context.loadModule)(message.url);
        const result = evaluateModule(publicPath, message.url, source);
        return { name: message.name, result };
    }));
    for (const module of loadedModules) {
        html = html.replace(`\${${module.name}}`, module.result);
    }
    return parser(html);
};
//# sourceMappingURL=posthtml-plugin-load-imports.js.map